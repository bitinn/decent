{"name":"Decent","tagline":"A redis-based job queue for Node: job queue is hard, so we make it decent for you.","body":"\r\ndecent\r\n======\r\n\r\n[![npm version](https://badge.fury.io/js/decent.svg)](http://badge.fury.io/js/decent) [![Build Status](https://travis-ci.org/bitinn/decent.svg?branch=master)](https://travis-ci.org/bitinn/decent) [![Coverage Status](https://img.shields.io/coveralls/bitinn/decent.svg)](https://coveralls.io/r/bitinn/decent) [![Dependency Status](https://david-dm.org/bitinn/decent.svg)](https://david-dm.org/bitinn/decent)\r\n\r\n`decent` is a Redis-based job queue for Node.\r\n\r\n*Job queue is hard to manage, we make it decent for you.*\r\n\r\n\r\n# Motivation\r\n\r\nDespite efforts from brilliant developers, a reliable job queue using node.js and redis is still somewhat of a mythical beast. And no wonder: redis isn't a queueing solution by itself and node.js isn't known for superior error handling; add concurrency into the mix and you got a leaky pipeline that's almost impossible to debug.\r\n\r\nIn short, we need better groundwork before we can harness the power of queue. Hence the birth of `decent`: we want a library that provides solid building blocks for complex pipelines, so we can safely enjoy what job queue has to offer.\r\n\r\n\r\n# Features\r\n\r\n- **Simple API**, powered by `Promise`, works in harmony with your generator library.\r\n- **Proper code coverage**, we put extra emphasis on negative tests, because that's when most queues fall apart and cause headaches.\r\n- **Annotated source code**, less than 700 loc in total.\r\n- No dependency besides `redis` driver, make use of native promise whenever possible, fallback to `bluebird` for older Node release.\r\n- Rich events to aid automation, status monitoring or building larger pipeline.\r\n\r\n\r\n# Install\r\n\r\n`npm install decent --save`\r\n\r\n\r\n# API\r\n\r\n\r\n## decent(name, opts)\r\n\r\nCreate a queue with `name` and config redis client connection based on `opts`, returns a decent queue instance.\r\n\r\n### examples\r\n\r\n```\r\nvar decent = require('decent');\r\n\r\nvar queue1 = decent('q1');\r\nvar queue2 = decent('q2', { \r\n\tport: 6379\r\n\t, host: 'localhost'\r\n\t, connect_timeout: 5000 \r\n});\r\n```\r\n\r\n### opts\r\n\r\n- `port`: redis server port, default to `6379`\r\n- `host`: redis server host, default to `'127.0.0.1'`\r\n- `blockTimeout`: how long a client should wait for next job (see redis document on blocking command, such as [BLPOP](http://redis.io/commands/BLPOP)), defaults to `30` seconds, `0` to block forever.\r\n- `maxRetry`: how many retries a job can have before being moved to failure queue, defaults to `3`, `0` to disable retry.\r\n- and all [redis client options](https://github.com/mranney/node_redis#rediscreateclient).\r\n\r\n\r\n## queue.add(data, opts)\r\n\r\nCreate a job on queue using `data` as payload and allows job specific `opts`, returns a promise that resolve to the created job.\r\n\r\n### examples\r\n\r\n```\r\nqueue.add({ a: 1 }).then(function(job) {\r\n\tconsole.log(job.data); // { a: 1 }\r\n});\r\n\r\nqueue.add({ a: 1, b: 1 }, { retry: 1, timeout: 120 }).then(function(job) {\r\n\tconsole.log(job.data); // { a: 1, b: 1 }\r\n});\r\n```\r\n\r\n### opts\r\n\r\n- `retry`: set initial retry counter, default to `0`\r\n- `timeout`: set worker timeout in seconds, default to `60`\r\n\r\n### job\r\n\r\n- `id`: job id\r\n- `data`: payload\r\n- `retry`: current retry count for this job\r\n- `timeout`: how many seconds a worker can run before it's terminated.\r\n\r\n\r\n## queue.worker(handler)\r\n\r\nRegister a handler function that process jobs, and start processing jobs in queue.\r\n\r\n### examples\r\n\r\n```\r\nqueue.worker(function(job, done) {\r\n\r\n\t// ... do actual work\r\n\r\n\tdone();\r\n});\r\n```\r\n\r\n### done(err);\r\n\r\nMust be called to signal the completion of job processing.\r\n\r\nIf called with an instance of `Error`, then `decent` will assume worker failed to process this job.\r\n\r\nFail jobs are moved back to work queue when they are below retry threshold, otherwise they are moved to failure queue.\r\n\r\n\r\n## queue.count(name)\r\n\r\nReturns a promise that resolve to the queue length of specified queue, default to `work` queue.\r\n\r\n### examples\r\n\r\n```\r\nqueue.count('work').then(function(count) {\r\n\tconsole.log(count); // pending job count\r\n});\r\n\r\nqueue.count('run').then(function(count) {\r\n\tconsole.log(count); // running job count\r\n});\r\n\r\nqueue.count('fail').then(function(count) {\r\n\tconsole.log(count); // failed job count\r\n});\r\n```\r\n\r\n\r\n## queue.get(id)\r\n\r\nReturns a promise that resolve to the job itself.\r\n\r\n### examples\r\n\r\n```\r\nqueue.get(1).then(function(job) {\r\n\tconsole.log(job.id); // 1\r\n});\r\n```\r\n\r\n\r\n## queue.remove(id)\r\n\r\nReturns a promise that will resolve when job is removed from redis (both job data and job queue).\r\n\r\n### examples\r\n\r\n```\r\nqueue.remove(1).then(function() {\r\n\t// ...\r\n});\r\n```\r\n\r\n\r\n## queue.stop()\r\n\r\nInstructs queue worker to terminate gracefully on next loop. See events on how to monitor queue.\r\n\r\n### examples\r\n\r\n```\r\nqueue.stop();\r\n```\r\n\r\n\r\n## queue.restart()\r\n\r\nRestarts the queue worker loop. See events on how to monitor queue.\r\n\r\n### examples\r\n\r\n```\r\nqueue.restart();\r\n```\r\n\r\n\r\n# Events\r\n\r\n`decent` is an instance of `EventEmitter`, so you can use `queue.on('event', func)` as usual.\r\n\r\n## Redis client related\r\n\r\n- `queue.emit('client ready')`: client is ready. (redis client has buffer built-in, so this event is emitted as soon as redis client is started.)\r\n- `queue.emit('client error', err)`: client connection experiences error.\r\n- `queue.emit('client close')`: client connection has been closed.\r\n- `queue.emit('client pressure', number)`: pending number of commands, useful for rate limiting.\r\n\r\n## queue worker related\r\n\r\n- `queue.emit('queue start')`: queue loop has started.\r\n- `queue.emit('queue ok', job)`: queue worker has processed a `job`.\r\n- `queue.emit('queue error', err)`: queue worker has failed to processed a job and thrown `err` (caught properly, so queue does not exit)\r\n- `queue.emit('queue exit', err)`: queue loop has terminated due to `err`.\r\n- `queue.emit('queue stop')`: queue loop has stopped gracefully.\r\n\r\n## queue client related\r\n\r\n- `queue.emit('add ok', job)`: `job` has been added to queue.\r\n- `queue.emit('add error', err)`: failed to add job onto queue due to `err`.\r\n\r\n\r\n# Development\r\n\r\n```\r\nnpm install\r\nnpm test\r\n```\r\n\r\nFeel feel to raise any issues or feature requests, note that we do intend to keep this API simple, and all changes must be well-tested.\r\n\r\n\r\n# Future plan\r\n\r\n- API for re-queueing failed jobs\r\n- Use-case examples\r\n- Web UI\r\n\r\n\r\n# License\r\n\r\nMIT\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}