{"name":"Decent","tagline":"A redis-based job queue for Node: job queue is hard, so we make it decent for you.","body":"\r\ndecent\r\n======\r\n\r\n[![npm version][npm-image]][npm-url]\r\n[![build status][travis-image]][travis-url]\r\n[![coverage status][coveralls-image]][coveralls-url]\r\n[![dependency status][david-image]][david-url]\r\n\r\n`decent` is a decent Redis job queue for Node.js\r\n\r\n\r\n# Motivation\r\n\r\nThere are powerful job queue modules for node.js + redis out there, like [kue](https://github.com/LearnBoost/kue) and [bull](https://github.com/OptimalBits/bull), to name a few. But powerful API comes at a price, they need complex data structure and redis scripts to achieve features such as delayed job, pause/resume and full text search. And since redis doesn't have traditional transaction, ie. [no rollback when one of the command failed](http://redis.io/topics/transactions), and [doesn't trigger error in node-redis driver](https://github.com/mranney/node_redis/issues/689), things can go south without developers noticing. Plus it's difficult to figure out what really happened due to non-intuitive redis data structure.\r\n\r\nTo us, the proper answer is to design around this problem, instead of adding more features, we want a job queue that's barebone, fully tested, easy to inspect, and doesn't hide errors from developers.\r\n\r\n\r\n# Features\r\n\r\n- Simple API with promise, works with your co/koa/whatever generator library.\r\n- Automatic job recovery that ease queue shutdown and restart.\r\n- Make use of native promise, and allow your favorite alternative.\r\n- Only dependency is the redis driver.\r\n\r\n\r\n# Install\r\n\r\n`npm install decent --save`\r\n\r\n\r\n# Usage\r\n\r\nTODO\r\n\r\n\r\n# API\r\n\r\n## decent(name, opts)\r\n\r\nCreate a queue with `name` and config redis client connection based on `opts`, returns a decent queue instance.\r\n\r\n### examples\r\n\r\n```\r\nvar decent = require('decent');\r\n\r\nvar queue1 = decent('q1');\r\nvar queue2 = decent('q2', { \r\n\tport: 6379\r\n\t, host: 'localhost'\r\n\t, connect_timeout: 5000 \r\n});\r\n```\r\n\r\n### opts\r\n\r\n- `port`: redis server port, default to `6379`\r\n- `host`: redis server host, default to `'127.0.0.1'`\r\n- `blockTimeout`: how long a client should wait for next job (see redis document on blocking command, such as [BLPOP](http://redis.io/commands/BLPOP)), defaults to `60` seconds, `0` to block forever.\r\n- `maxRetry`: how many retries a job can have before being moved to failure queue, defaults to `3`, `0` to disable retry.\r\n- and all [redis client options](https://github.com/mranney/node_redis#rediscreateclient).\r\n\r\n\r\n## queue.add(data, opts)\r\n\r\nCreate a job on queue using `data` as payload and allows job specific `opts`, returns a promise that resolve to the created job.\r\n\r\n### examples\r\n\r\n```\r\nqueue.add({ a: 1 }).then(function(job) {\r\n\tconsole.log(job.data); // { a: 1 }\r\n});\r\n\r\nqueue.add({ a: 1, b: 1 }, { retry: 1, timeout: 120 }).then(function(job) {\r\n\tconsole.log(job.data); // { a: 1, b: 1 }\r\n\tconsole.log(job.retry); // 1\r\n\tconsole.log(job.timeout); // 120\r\n});\r\n```\r\n\r\n### opts\r\n\r\n- `retry`: set initial retry counter, default to `0`\r\n- `timeout`: set worker timeout in seconds, default to `60`\r\n\r\n### job\r\n\r\n- `id`: job id\r\n- `data`: payload\r\n- `retry`: current retry count for this job\r\n- `timeout`: how many seconds a worker can run before it's terminated.\r\n- `queue`: which queue this job currently belongs to.\r\n\r\n\r\n## queue.worker(handler)\r\n\r\nRegister a handler function that process jobs, and start processing jobs in queue.\r\n\r\n### examples\r\n\r\n```\r\nqueue.worker(function(job, done) {\r\n\tsetTimeout(function() {\r\n\t\tconsole.log(job.data);\r\n\t\tdone();\r\n\t}, 100);\r\n});\r\n```\r\n\r\n### done(err);\r\n\r\nMust be called to signal the completion of job processing.\r\n\r\nIf called with an instance of `Error`, then `decent` will assume worker failed to process this job.\r\n\r\nFail jobs are moved back to work queue when they are below retry threshold, otherwise they are moved to failure queue.\r\n\r\n\r\n## queue.count(name)\r\n\r\nReturns a promise that resolve to the queue length of specified queue, default to `work` queue.\r\n\r\n### examples\r\n\r\n```\r\nqueue.count('work').then(function(count) {\r\n\tconsole.log(count); // pending job count\r\n});\r\n\r\nqueue.count('run').then(function(count) {\r\n\tconsole.log(count); // running job count\r\n});\r\n\r\nqueue.count('fail').then(function(count) {\r\n\tconsole.log(count); // failed job count\r\n});\r\n```\r\n\r\n\r\n## queue.get(id)\r\n\r\nReturns a promise that resolve to the job itself.\r\n\r\n### examples\r\n\r\n```\r\nqueue.get(1).then(function(job) {\r\n\tconsole.log(job.id); // 1\r\n});\r\n```\r\n\r\n\r\n## queue.remove(id, name)\r\n\r\nReturns a promise that will resolve when job is removed from redis (both job data and job queue). Default queue is `work`.\r\n\r\nNote: `remove` does not return the job, use `get` then `remove` instead.\r\n\r\n### examples\r\n\r\n```\r\nqueue.remove(1, 'run').then(function() {\r\n\t// job has been removed from redis\r\n});\r\n```\r\n\r\n\r\n## queue.stop()\r\n\r\nInstructs queue worker to terminate gracefully on next loop. See events on how to monitor queue.\r\n\r\n### examples\r\n\r\n```\r\n// ... setup queue and worker\r\n\r\nqueue.on('queue stop', function() {\r\n\tconsole.log('queue stopped gracefully');\r\n});\r\nqueue.stop();\r\n```\r\n\r\n\r\n## queue.restart()\r\n\r\nRestarts the queue worker loop. See events on how to monitor queue.\r\n\r\n### examples\r\n\r\n```\r\n// ... setup queue and worker\r\n\r\nqueue.on('queue start', function() {\r\n\tconsole.log('queue restarted');\r\n});\r\nqueue.restart();\r\n```\r\n\r\n\r\n# Events\r\n\r\n`decent` is an instance of `EventEmitter`, so you can use `queue.on('event', func)` as usual.\r\n\r\n## queue worker related\r\n\r\n- `queue.emit('queue start')`: queue loop has started.\r\n- `queue.emit('queue work', job)`: queue worker begin to process a `job`.\r\n- `queue.emit('queue ok', job)`: queue worker has processed a `job`.\r\n- `queue.emit('queue error', err, job)`: queue worker has failed to processed a `job` and thrown `err`, will retry later.\r\n- `queue.emit('queue failure', err, job)`: queue worker has failed to processed a `job` and thrown `err`, retry limit reached.\r\n- `queue.emit('queue exit', err)`: queue loop has terminated due to unhandled `err`.\r\n- `queue.emit('queue stop')`: queue loop has stopped gracefully.\r\n\r\n\r\n# License\r\n\r\nMIT\r\n\r\n[npm-image]: https://img.shields.io/npm/v/decent.svg?style=flat-square\r\n[npm-url]: https://www.npmjs.com/package/decent\r\n[travis-image]: https://img.shields.io/travis/bitinn/decent.svg?style=flat-square\r\n[travis-url]: https://travis-ci.org/bitinn/decent\r\n[coveralls-image]: https://img.shields.io/coveralls/bitinn/decent.svg?style=flat-square\r\n[coveralls-url]: https://coveralls.io/r/bitinn/decent\r\n[david-image]: https://img.shields.io/david/bitinn/decent.svg?style=flat-square\r\n[david-url]: https://david-dm.org/bitinn/decent\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}